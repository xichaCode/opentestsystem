package open.xibu.open.test.calculation.impl.template;

import lombok.extern.slf4j.Slf4j;
import open.test.calculation.api.beans.Product;
import open.test.calculation.api.beans.ShoppingCart;
import open.xibu.open.test.template.api.beans.OpenTemplateInfo;
import open.xibu.open.test.template.api.beans.OpenTestInfo;
import open.xibu.open.test.template.api.beans.PagedOpenTestTemplateInfo;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * @ClassName AbstractRuleTemplate
 * @Description 定义通用的计算逻辑
 * @Author xibu
 * @Date AbstractRuleTemplate 18:22
 * @Version 1.0
 **/
@Slf4j
public abstract  class AbstractRuleTemplate implements RuleTemplate{

    @Override
    public ShoppingCart calculate(ShoppingCart order){

        Long orderTotalAmount = getTotalPrice(order.getProductList());

        Map<Long ,Long> sumAmount = this.getTotalPriceGroupByShop(order.getProductList());

        OpenTemplateInfo templateInfo = order.getOpenTestInfos().get(0).getTemplate();

        Long threshold = templateInfo.getRule().getDiscount().getThreshold();

        Long quota = templateInfo.getRule().getDiscount().getQuota();

        Long shopId = templateInfo.getShopId();

        Long shopTotalAmount = (shopId == null) ? orderTotalAmount : sumAmount.get(shopId);

        if(shopTotalAmount == null || shopTotalAmount < threshold){
            log.warn("Totals of amount not meet, ur coupons are not applicable to this order");
            order.setCost(orderTotalAmount);
            order.setOpenTestInfos(Collections.emptyList());
            return order;
        }

        Long newCost = calculateNewPrice(orderTotalAmount,shopTotalAmount,quota);
        if(newCost < minCost()){
            newCost = minCost();
        }
        order.setCost(newCost);
        log.debug("original price ={}, new price ={}",orderTotalAmount,newCost);
        return order;
    }

    /**
     * desc: 金额计算具体逻辑，延迟到子类实现
     * @param orderTotalAmount
     * @param shopTotalAmount
     * @param quota
     * @return
     */
    abstract protected Long calculateNewPrice(Long orderTotalAmount, Long shopTotalAmount,Long quota);
    /**
     * 计算订单总价
     * @param productList
     * @return
     */
    protected long getTotalPrice(List<Product> productList){
        return productList.stream()
                .mapToLong(product -> product.getPrice() * product.getCount())
                .sum();
    }

    /**
     * dec : 根据门店维度计算每个门店下商品价格
     *
     * @param productList key= shopId,value=门店商品价格
     * @return
     */
    protected Map<Long, Long> getTotalPriceGroupByShop(List<Product> productList){
        Map<Long,Long> groups = productList.stream()
                .collect(Collectors.groupingBy(m->m.getShopId(),Collectors.summingLong(p -> p.getPrice() * p.getCount())));
        return groups;
    }

    /**
     * desc : 每个订单最少必须支付1分钱
     * @return
     */
    protected long minCost(){
        return 1L;
    }

    protected long convertToDecimal(Double value){
        return new BigDecimal(value).setScale(0, RoundingMode.HALF_UP).longValue();
    }
}
